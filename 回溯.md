# 理论基础
回溯法效率不是很高，一般用来解决组合，切割，子集，排列和棋盘问题。
### 如何理解回溯法
**回溯法解决的问题都可以抽象为树形结构*
采用递归一层一层往下，处理每一层，再回溯，撤销结果。
### 回溯法模板
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```
# 组合
## 题目：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]

## 解法
直接想法是for循环，几个k就几个循环，缺点很明显哦

**写递归函数，要确定终止条件，调用的参数和返回值**
* 返回值是一个二维数组，返回所有的组合
* 当到达第k层时，到达终止条件
* 参数集合n和k。
```cpp
{

}

```
# N皇后
### 题目描述 编写一个函数，求解皇后问题：在 $n^n$ 的方格棋盘上，放置 $n$ 个皇后，要求每个皇后不同行、不同列、不同左右对角线。要求：1、皇后的个数由用户输入，其值不超过 $20$，输出所有的解。2、采用递归回溯的方法解决。      
**输入**
     输入一个整数 $n$，代表棋盘的大小，        
**输出**
   将计算出的彼此不受攻击的 $n$ 个皇后的所有放置方案输出，每种方案占一行。
## 解法
思路是这样的，我们用递归来遍历每一层棋盘，尝试把皇后放到每行的每一个位置，然后再用函数判断位置是否满足条件
* 递归函数的参数
  二维数组reslut记录最终棋盘
  n棋盘大小
  row记录遍历的层数
  col记录每一层遍历的位置
* 终止条件：row==n
* 验证棋盘是否合法：
  1.不同行
  2.不同列
  3.不同斜线
  是否合法的代码：
```cpp
bool isvalid(int row,int col,vector<string> &chessboard,int n){
     //检查lie
     for(int i=0;i<row;i++){
        if(chessboard[i][col]=='Q'){
        return false;
     }
}
    for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++){
       if(chessboard[i][col]=='Q'){
        return false;
     }
    }
   for(int i=row-1,j=col-1;j>=0,i>=0;i--,j--){
       if(chessboard[i][col]=='Q'){
        return false;
     }
}
return true;
}
```
不用对每一行检查哦，for循环只会选一个；
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<vector<string>> result;
vector<string> chessboard;

bool isvalid(int row, int col) {
    for (int i = 0; i < row; i++) {
        if (chessboard[i][col] == 'Q') return false;
    }
    for (int i = row-1, j = col+1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') return false;
    }
    for (int i = row-1, j = col-1; j >= 0 && i >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') return false;
    }
    return true;
}

void trackback(int row) {
    if (row == n) {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isvalid(row, col)) {
            chessboard[row][col] = 'Q';
            trackback(row + 1);
            chessboard[row][col] = '.';
        }
    }
}

int main() {
    cin >> n;
    chessboard = vector<string>(n, string(n, '.')); 
    trackback(0);
    
    for (auto& solution : result) {
        vector<int> cols(n);
        for (int i = 0; i < n; ++i) {
            cols[i] = solution[i].find('Q') + 1;  // 修正此处变量名错误
        }
        for (int i = 0; i < n; ++i) {
            cout << cols[i];
            if (i != n-1) cout << " ";
        }
        cout << endl;
    }
    return 0;
}
  ```
   这个字符串数组我是不会输出的，好像是岸上面那个格式，for里面定义auto& a:目标数组，a相当于取了目标字符串数组的每一行。
